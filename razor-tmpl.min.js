//------------------------------------
// Created BY Magicdawn
// 2014-7-17 17:54:14
//http://tool.oschina.net/jscompress
//------------------------------------
String.prototype.razorReplaceAll = function (oldValue, replaceValue) { return this.replace(new RegExp(oldValue, "g"), replaceValue) }; String.prototype.razorFormat = function (obj0, obj1, obj2) { var result = this; for (var i in arguments) { result = result.razorReplaceAll("\\{" + i + "\\}", arguments[i].toString()) } return result }; (function (global) { var version = "0.8.0"; var update_date = "2014-7-17"; "use strict"; function simpleMinfy(str, isJsCode) { if (isJsCode) { str = str.replace(/\/\/.*$/gm, "").replace(/\/\*[\s\S]*\*\//g, "") } return str.replace(/@\*[\s\S]*?\*@]/g, "").replace(/\n+/g, "\n").replace(/ +/g, " ").replace(/<!--[\s\S]*?-->/g, "").trim() } var ESegmentType = { CodeBlock: 0, Variable: 1, String: 2 }; function Segment(content, eSegmentType) { this.Content = content; this.SegmentType = eSegmentType } function StringBlockModel(template) { this.template = template; this.processedIndex = -1; this.segments = [] } var Regexs = { ForWhile: /^(for|while)\s*?\([\s\S]*?\)\s*?\{[\s\S]*?\}/, If: /^if\s*\([\s\S]*?\)\s*\{/, Else: /^\}\s*else/, Each: /^each\s*?\([\s\S]+?\)\s*?\{[\s\S]*?\}/ }; var SegementProcesser = { symbol: "@", process: function (template) { var model = new StringBlockModel(template); this.processStringBlock(model); return model.segments }, processStringBlock: function (model) { var template = model.template; for (var index = 0, length = template.length; index < length; index++) { var current = template[index]; var next = ""; if (current == this.symbol) { this.processString(model, index); next = template[index + 1]; if (next == this.symbol) { index = this.processEscapeSymbol(model, index); continue } else { if (next == "*") { index = this.processComment(model, index); continue } else { var tokenIndex = index + 1; while (next == " " || next == "\n") { next = template[++tokenIndex] } switch (next) { case "{": index = this.processCodeBlock(model, index, tokenIndex); break; case "(": index = this.processVariable(model, index, tokenIndex); break; default: var remain = model.template.substring(tokenIndex); if (Regexs.ForWhile.test(remain)) { index = this.processForWhile(model, index, tokenIndex) } else { if (Regexs.Each.test(remain)) { index = this.processEach(model, index, tokenIndex) } else { if (Regexs.If.test(remain)) { index = this.processIfElse(model, index, tokenIndex) } } } break } } } } } var content = model.template.substring(model.processedIndex + 1, model.template.length); if (content) { model.segments.push(new Segment(content, ESegmentType.String)) } }, processString: function (model, atIndex) { var content = model.template.substring(model.processedIndex + 1, atIndex); if (content) { model.segments.push(new Segment(content, ESegmentType.String)) } model.processedIndex = atIndex - 1 }, processComment: function (model, atIndex) { var remain = model.template.substring(atIndex); var xingIndex = remain.indexOf("*" + this.symbol); if (xingIndex > -1) { var commentEnd = xingIndex + atIndex + 1; model.processedIndex = commentEnd; return commentEnd } else { throw Error("注释错误"); return atIndex + 1 } }, processEscapeSymbol: function (model, atIndex) { model.segments.push(new Segment(this.symbol, ESegmentType.String)); model.processedIndex = atIndex + 1; return model.processedIndex }, processCodeBlock: function (model, atIndex, firstBraceIndex) { var secondBraceIndex = this.getSecondIndex(model.template, firstBraceIndex); var content = model.template.substring(firstBraceIndex + 1, secondBraceIndex); if (content) { content = this.decodeHtmlEntity(content); model.segments.push(new Segment(content, ESegmentType.CodeBlock)) } return model.processedIndex = secondBraceIndex }, processVariable: function (model, atIndex, firstBraceIndex) { var secondBraceIndex = this.getSecondIndex(model.template, firstBraceIndex); var content = model.template.substring(atIndex + 2, secondBraceIndex).trim(); if (content) { content = this.decodeHtmlEntity(content); if (/^-/g.test(content)) { content = content.substring(1).trim(); content += ".replace(/&/g,'&amp;')"; content += ".replace(/</g,'&lt;')"; content += ".replace(/>/g,'&gt;')"; content += ".replace(/'/g,'&#39;')"; content += '.replace(/"/g,"&#34;")'; content += ".replace(/\\//g,'&#47;')"; model.segments.push(new Segment(content, ESegmentType.Variable)) } else { if (/^=/g.test(content)) { content = content.substring(1).trim(); content = SegmentCompiler.modelName + "." + content; model.segments.push(new Segment(content, ESegmentType.Variable)) } else { model.segments.push(new Segment(content, ESegmentType.Variable)) } } } return model.processedIndex = secondBraceIndex }, processForWhile: function (model, atIndex) { var remain = model.template.substring(atIndex); var firstIndex = remain.indexOf("{") + atIndex; var secondIndex = this.getSecondIndex(model.template, firstIndex); var part1 = model.template.substring(atIndex + 1, firstIndex + 1); var part2 = model.template.substring(firstIndex + 1, secondIndex); var part3 = "}"; part1 = this.decodeHtmlEntity(part1); model.segments.push(new Segment(part1, ESegmentType.CodeBlock)); var subSegments = this.process(part2); model.segments = model.segments.concat(subSegments); model.segments.push(new Segment(part3, ESegmentType.CodeBlock)); return model.processedIndex = secondIndex }, processEach: function (model, atIndex) { var remain = model.template.substring(atIndex); var firstBraceIndex = remain.indexOf("(") + atIndex; var secondBraceIndex = this.getSecondIndex(model.template, firstBraceIndex); var firstBigIndex = remain.indexOf("{") + atIndex; var secondBigIndex = this.getSecondIndex(model.template, firstBigIndex); var loop = model.template.substring(firstBraceIndex + 1, secondBraceIndex); var inIndex = loop.indexOf("in"); var item = loop.substring(0, inIndex).trim(); var items = loop.substring(inIndex + 2).trim(); var loopCode = "for(var $index = 0,length = {1}.length;$index < length;$index++) { var {0} = {1}[$index];".razorFormat(item, items); model.segments.push(new Segment(loopCode, ESegmentType.CodeBlock)); var loopContent = model.template.substring(firstBigIndex + 1, secondBigIndex); var innerSegments = this.process(loopContent); model.segments = model.segments.concat(innerSegments); model.segments.push(new Segment("}", ESegmentType.CodeBlock)); return model.processedIndex = secondBigIndex }, processIfElse: function (model, atIndex) { var remain = model.template.substring(atIndex); var firstIfBrace = remain.indexOf("{") + atIndex; var secondIfBrace = this.getSecondIndex(model.template, firstIfBrace); var ifpart1 = model.template.substring(atIndex + 1, firstIfBrace + 1); var ifpart2 = model.template.substring(firstIfBrace + 1, secondIfBrace); var ifpart3 = "}"; ifpart1 = this.decodeHtmlEntity(ifpart1); model.segments.push(new Segment(ifpart1, ESegmentType.CodeBlock)); var ifInnerSegments = this.process(ifpart2); model.segments = model.segments.concat(ifInnerSegments); model.segments.push(new Segment(ifpart3, ESegmentType.CodeBlock)); model.processedIndex = secondIfBrace; remain = model.template.substring(model.processedIndex); while (Regexs.Else.test(remain)) { var firstElseBrace = remain.indexOf("{") + model.processedIndex; var secondeElseBrace = this.getSecondIndex(model.template, firstElseBrace); var elsepart1 = model.template.substring(model.processedIndex + 1, firstElseBrace + 1); var elsepart2 = model.template.substring(firstElseBrace + 1, secondeElseBrace); var elsepart3 = "}"; model.segments.push(new Segment(elsepart1, ESegmentType.CodeBlock)); var elseInnerSegments = this.process(elsepart2); model.segments = model.segments.concat(elseInnerSegments); model.segments.push(new Segment(elsepart3, ESegmentType.CodeBlock)); model.processedIndex = secondeElseBrace; remain = model.template.substring(model.processedIndex) } return model.processedIndex }, getSecondIndex: function (template, firstIndex) { var pair = { "{": "}", "(": ")" }; var first = template.substr(firstIndex, 1); var second = pair[first]; var count = 1; for (var index = firstIndex + 1, length = template.length; index < length; index++) { var cur = template.substr(index, 1); if (cur == second) { count--; if (count == 0) { break } } else { if (cur == first) { count++ } } } return index }, decodeHtmlEntity: function (variable) { return variable.razorReplaceAll("&lt;", "<").razorReplaceAll("&gt;", ">").razorReplaceAll("&amp;", "&") } }; var SegmentCompiler = { modelName: "ViewBag", mode: "normal", escapeInFunction: function (str) { if (!str) { return str } return str.replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/(\r?\n)+/g, "\\n") }, compile: function (segments) { var functionContent = []; functionContent.push("var $result='';"); try { for (var i in segments) { var data = segments[i].Content; switch (segments[i].SegmentType) { case ESegmentType.CodeBlock: functionContent.push(data); break; case ESegmentType.Variable: var inner = "$result+={0};".razorFormat(data); functionContent.push(inner); break; case ESegmentType.String: var inner = "$result+='{0}';".razorFormat(this.escapeInFunction(data)); functionContent.push(inner); break; default: break } } functionContent.push("return $result;"); return new Function(this.modelName, functionContent.join("\n")) } catch (e) { console.log("new Function出错,请检查 模板语法 ..."); console.log(e); console.log(functionContent.join("\n")); return new Function("return '';") } } }; var razor = { compile: function (template) { var segments = SegementProcesser.process(template); var func = SegmentCompiler.compile(segments); return func }, render: function (template, ViewBag) { if (!this.withViewBag) { var codeDef = ""; for (var key in ViewBag) { codeDef += "var {0} = ViewBag['{0}'];".razorFormat(key) } template = "@{" + codeDef + "}" + template } var func = this.compile(template); return func(ViewBag) }, withViewBag: true, symbol: function (newSymbol) { if (!newSymbol) { return SegementProcesser.symbol } SegementProcesser.symbol = newSymbol; return this }, model: function (newModelName) { if (!newModelName) { return SegmentCompiler.modelName } SegmentCompiler.modelName = newModelName; return this }, init: function () { this.withViewBag = true; return this.symbol("@").model("ViewBag") }, version: version, update_date: update_date, encodeHtml: function (str) { return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&#34;").replace(/\//g, "&#47;") }, decodeHtml: function (str) { return SegementProcesser.decodeHtmlEntity(str) } }; if (typeof (module) != "undefined" && module.exports) { module.exports = razor } else { global.razor = razor } if (typeof ($) != "undefined" && $) { $(function () { $("[razor-template]").hide() }); var getLoopHeader = function (jqObj) { var attr = jqObj.attr("razor-for") || jqObj.attr("data-razor-for"); if (attr) { return "for({0}){".razorFormat(attr.trim()) } attr = jqObj.attr("razor-if") || jqObj.attr("data-razor-if"); if (attr) { return "if({0}){".razorFormat(attr.trim()) } attr = jqObj.attr("razor-while") || jqObj.attr("data-razor-while"); if (attr) { return "while({0}){".razorFormat(attr.trim()) } attr = jqObj.attr("razor-each") || jqObj.attr("data-razor-each"); if (attr) { return "each({0}){".razorFormat(attr) } return "" }; var getTemplate = function (jqObj) { var template = jqObj[0].tagName === "SCRIPT" ? jqObj.html() : jqObj.attr("razor-template") || jqObj.html(); var loopHeader = getLoopHeader(jqObj); if (loopHeader) { template = SegementProcesser.symbol + loopHeader + template + "}" } return template }; $.fn.extend({ compile: function () { return razor.compile(getTemplate(this)) }, render: function (ViewBag) { var template = getTemplate(this); var result = razor.render(template, ViewBag); if (this[0].tagName !== "SCRIPT") { if (!this.attr("razor-template")) { var innerTemplate = this.html().trim(); this.attr("razor-template", innerTemplate) } this.html(result); this.show() } return result }, renderToParent: function (ViewBag) { var html = this.render(ViewBag); this.parent().append(html) } }) } })(this);